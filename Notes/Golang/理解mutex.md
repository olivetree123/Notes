# 理解 mutex

## Critical Section
在学习 mutex 之前，我们有必要理解协程编程中的**critical section**。当多个协程并发的时候，修改共享资源的代码片段不能同时被多个协程访问。修改共享资源的代码片段被称为 **critical section**。  
比如，假设有如下这样一个代码片段：
``` Go
x = x + 1
```
我们来看看这个代码片段被多个协程同时访问会出现什么问题。  
简单起见，我们假设有 2 个协程同时运行上面的代码片段。  
在计算机内部，该代码片段的执行步骤如下：
``` js
1. 获取 x 当前的值
2. 计算 x + 1
3. 将计算结果赋值给 x  
```
(真实的计算过程会更加复杂，我们暂时认为只有这三个步骤)  
在 2 个协程的情况下，下图描述了一种可能计算过程：

![计算过程](../img/cs5.png)
#### 执行过程说明
我们假设 x 初始值是 0
``` js
1. 协程 A 获取了 x 的初始值，并计算了 x + 1
2. 在 A 将计算结果赋值给 x 之前，系统切换到了协程 B
3. 这时协程 B 获取到了 x 的值为 0，并计算了 x + 1
4. 然后系统又切换回了 A
5. 协程 A 给 x 赋值为 1
6. 协程 B 给 x 赋值为 1
```
当然还会有另外一种计算过程，协程 A 一次性执行了 3 个步骤之后，系统才切换到协程 B，这时 B 获得的 x 值为 1，最终结果是 x 变成了 2。  
所以我们可以看出，不同的上下文切换会导致最终结果的不同。这其实就是竞争条件漏洞。  
在上面的例子中，如果该代码片段每个时刻只允许一个协程访问，竞争条件漏洞其实是可以避免的。  
要想解决竞争条件漏洞的问题，可以通过 Mutex 来实现。
## Mutex
Mutex 是用来提供锁机制，使得一个时刻只能有一个协程访问一个代码片段，这样就可以避免竞争条件漏洞的发生。
``` Go
mutex.Lock()  
x = x + 1  
mutex.Unlock() 
```
在上面的代码中 `x = x + 1` 将只能被一个协程访问。如果协程 A 没有执行完该代码片段，则即便切换到其他协程，其他协程也只能处于 block 状态等待锁的释放。

## Channel
其实也可以使用 channel 来解决竞争条件漏洞的问题
``` Go
package main  
import (  
    "fmt"
    "sync"
    )
var x  = 0  
func increment(wg *sync.WaitGroup, ch chan bool) {  
    ch <- true
    x = x + 1
    <- ch
    wg.Done()   
}
func main() {  
    var w sync.WaitGroup
    ch := make(chan bool, 1)
    for i := 0; i < 1000; i++ {
        w.Add(1)        
        go increment(&w, ch)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}
```
这里创建了一个长度为 1 的 channel，每个协程在执行`x = x + 1` 之前，都要往 channel 中放数据，如果放不进去，则会 block。所以可以保证`x = x + 1` 的原子性。

## 说明
上面所说的**一个时刻只能有一个协程访问该代码片段**，并不是说两个协程可以同时执行同一个代码片段，因为同一个进程中的不同协程是不会同时执行的，它们是并发的不是并行的，每个时刻只会有一个协程在运行。系统从协程 A 切换到协程 B，则 A 停止了执行，B 开始执行，但我们认为 A 和 B 两个协程都是存在的，而且 A 依然在访问它最后执行的代码片段，只是处在 block 状态。

## Race Condition
一般翻译成**竞态条件**，但是这样翻译其实不是很好理解，有人翻译成**竞争条件漏洞**，我觉得这个更好理解一些，因为这其实算是一个漏洞，因为无序的资源竞争而产生的一个漏洞。  
> 由于多个进程或协程同一时刻竞争使用同一份资源，使得这些进程有可能因为时间上推进的先后原因而出现不同的结果，这叫做竞争条件漏洞（Race Condition）
## 参考
> [Part 25: Mutex](https://golangbot.com/mutex/)